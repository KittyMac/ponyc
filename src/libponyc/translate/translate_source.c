#include "translate_json_schema.h"
#include "translate_text_resource.h"
#include "translate_c_header.h"
#include "../../libponyrt/gc/serialise.h"
#include "../../libponyrt/mem/pool.h"
#include "../pkg/program.h"
#include "../ast/ast.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>

#define PONY_EXTENSION ".pony"
#define JSON_SCHEMA_EXTENSION ".schema.json"

// text files which get converted into code
#define MARKDOWN_EXTENSION ".md"
#define JSON_EXTENSION ".json"
#define TEXT_EXTENSION ".txt"
#define INFO_PLIST_EXTENSION "Info.plist"
#define C_HEADER_EXTENSION ".h"

// converts a JSON Schema file to Pony classes. Used in source.c.

int string_ends_with(const char *str, const char *suffix)
{
    if (!str || !suffix)
        return 0;
    size_t lenstr = strlen(str);
    size_t lensuffix = strlen(suffix);
    if (lensuffix > lenstr)
        return 0;
    return strncmp(str + lenstr - lensuffix, suffix, lensuffix) == 0;
}

bool translate_valid_source_file(const char* file_name)
{
  if( string_ends_with(file_name, PONY_EXTENSION) ||
    
      string_ends_with(file_name, MARKDOWN_EXTENSION) ||
      string_ends_with(file_name, JSON_EXTENSION) ||
      string_ends_with(file_name, TEXT_EXTENSION) ||
      
      string_ends_with(file_name, JSON_SCHEMA_EXTENSION) ||
      
      string_ends_with(file_name, INFO_PLIST_EXTENSION) ||
      
      string_ends_with(file_name, C_HEADER_EXTENSION)
    )
  {
    return true;
  }
  return false;
}

char* translate_source(program_t* program, const char* file_name, const char* source_code, bool print_generated_code)
{
  if(string_ends_with(file_name, INFO_PLIST_EXTENSION))
  {
    // For Info.plist, we should transpile the code to a primitive with values to access. For now we're just going
    // to provide nothing, because what we really want is to link in the plist file
		ponyint_pool_free_size(strlen(source_code)+1, (void *)source_code);
  	char * empty_code = (char*)ponyint_pool_alloc_size(1);
  	empty_code[0] = 0;
    
    // Flag the program to link to use the -sectcreate __TEXT __info_plist /path/to/Info.plist    
    program_assign_info_plist(program, strdup(file_name));
    
    return empty_code;
  }
  else if(string_ends_with(file_name, C_HEADER_EXTENSION))
  {
    return translate_c_header(print_generated_code, file_name, source_code);
  }
  else if(string_ends_with(file_name, JSON_SCHEMA_EXTENSION))
  {
    return translate_json_schema(print_generated_code, file_name, source_code);
  }
  else if(string_ends_with(file_name, MARKDOWN_EXTENSION))
  {
    return translate_text_resource(print_generated_code, file_name, "Markdown", source_code);
  }
  else if(string_ends_with(file_name, JSON_EXTENSION))
  {
    return translate_text_resource(print_generated_code, file_name, "Json", source_code);
  }
  else if(string_ends_with(file_name, TEXT_EXTENSION))
  {
    return translate_text_resource(print_generated_code, file_name, "Text", source_code);
  }
  return (char *)source_code;
}


void translate_source_package_begin(const char * qualified_name) {
  translate_text_resource_package_begin(qualified_name);
}

char* translate_source_package_end(bool print_generated_code) {
  // All transpilers who need to add whole package code now have the opportunity to do that. But it all needs to be
  // in a single source file, so we handle giving them the sdsstring from here..
  
  sds code = sdsnew("");
  
  // the resource transpilier uses the package end call to create a class with LUT to the resources compiled in.
  code = translate_text_resource_package_end(code);
  
  
  // copy the code over to pony allocated memory
  size_t code_len = sdslen(code);
  char * pony_code = (char*)ponyint_pool_alloc_size(code_len + 1);
  strncpy(pony_code, code, code_len);
  pony_code[code_len] = 0;
  sdsfree(code);
  
  if (code_len > 0 && print_generated_code) {
    fprintf(stderr, "========================== autogenerated pony code ==========================\n");
    fprintf(stderr, "%s", pony_code);
    fprintf(stderr, "=============================================================================\n");
  }
  
  return pony_code;
}




// helper functions shared by future translation classes

char* translate_class_name(const char* name)
{
  // take a file name and turn it into a pony class name
  const char * start = strrchr(name, '/');
  if (start == NULL) {
    start = name;
  } else {
    start += 1;
  }
  const char * end = strchr(start, '.');
  if (end == NULL) {
    end = name + strlen(name);
  }
  
  char* class_name = (char*)ponyint_pool_alloc_size((end - start) + 1);
  
  int idx = 0;
  bool uppercase_next = true;
  for (; start < end; start++) {
    if (uppercase_next) {
      class_name[idx++] = (char)toupper(*start);
      uppercase_next = false;
      continue;
    }
    if (isspace(*start) == true || *start == '_') {
      uppercase_next = true;
      continue;
    }
    class_name[idx++] = (char)tolower(*start);
  }
  class_name[idx] = 0;
  
  return class_name;
}

char* translate_function_name(const char* name)
{
  // take a file name and turn it into a pony class name
  const char * start = strrchr(name, '/');
  if (start == NULL) {
    start = name;
  } else {
    start += 1;
  }
  const char * end = strchr(start, '.');
  if (end == NULL) {
    end = name + strlen(name);
  }
  
  char* class_name = (char*)ponyint_pool_alloc_size((end - start) + 1);
  
  int idx = 0;
  for (; start < end; start++) {
    if (isspace(*start) == true) {
      continue;
    }
    class_name[idx++] = (char)tolower(*start);
  }
  class_name[idx] = 0;
  
  return class_name;
}
